"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[372],{3905:(e,t,r)=>{r.d(t,{Zo:()=>p,kt:()=>f});var n=r(7294);function o(e,t,r){return t in e?Object.defineProperty(e,t,{value:r,enumerable:!0,configurable:!0,writable:!0}):e[t]=r,e}function a(e,t){var r=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),r.push.apply(r,n)}return r}function i(e){for(var t=1;t<arguments.length;t++){var r=null!=arguments[t]?arguments[t]:{};t%2?a(Object(r),!0).forEach((function(t){o(e,t,r[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(r)):a(Object(r)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(r,t))}))}return e}function s(e,t){if(null==e)return{};var r,n,o=function(e,t){if(null==e)return{};var r,n,o={},a=Object.keys(e);for(n=0;n<a.length;n++)r=a[n],t.indexOf(r)>=0||(o[r]=e[r]);return o}(e,t);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(n=0;n<a.length;n++)r=a[n],t.indexOf(r)>=0||Object.prototype.propertyIsEnumerable.call(e,r)&&(o[r]=e[r])}return o}var l=n.createContext({}),c=function(e){var t=n.useContext(l),r=t;return e&&(r="function"==typeof e?e(t):i(i({},t),e)),r},p=function(e){var t=c(e.components);return n.createElement(l.Provider,{value:t},e.children)},u={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},h=n.forwardRef((function(e,t){var r=e.components,o=e.mdxType,a=e.originalType,l=e.parentName,p=s(e,["components","mdxType","originalType","parentName"]),h=c(r),f=o,d=h["".concat(l,".").concat(f)]||h[f]||u[f]||a;return r?n.createElement(d,i(i({ref:t},p),{},{components:r})):n.createElement(d,i({ref:t},p))}));function f(e,t){var r=arguments,o=t&&t.mdxType;if("string"==typeof e||o){var a=r.length,i=new Array(a);i[0]=h;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s.mdxType="string"==typeof e?e:o,i[1]=s;for(var c=2;c<a;c++)i[c]=r[c];return n.createElement.apply(null,i)}return n.createElement.apply(null,r)}h.displayName="MDXCreateElement"},6777:(e,t,r)=>{r.r(t),r.d(t,{assets:()=>l,contentTitle:()=>i,default:()=>u,frontMatter:()=>a,metadata:()=>s,toc:()=>c});var n=r(7462),o=(r(7294),r(3905));const a={id:"overview",title:"Overview",sidebar_label:"Overview",slug:"/overview"},i=void 0,s={unversionedId:"overview",id:"overview",title:"Overview",description:"NOTE: These docs are under active development \ud83d\udc77\u200d\u2640\ufe0f\ud83d\udc77",source:"@site/docs/overview.md",sourceDirName:".",slug:"/overview",permalink:"/float-subgraph-uncrashable/docs/overview",draft:!1,editUrl:"https://github.com/Float-Capital/float-subgraph-uncrashable/tree/dev/docs/docs/overview.md",tags:[],version:"current",frontMatter:{id:"overview",title:"Overview",sidebar_label:"Overview",slug:"/overview"},sidebar:"someSidebar",previous:{title:"Welcome",permalink:"/float-subgraph-uncrashable/docs/"},next:{title:"Installation",permalink:"/float-subgraph-uncrashable/docs/installation"}},l={},c=[],p={toc:c};function u(e){let{components:t,...r}=e;return(0,o.kt)("wrapper",(0,n.Z)({},p,r,{components:t,mdxType:"MDXLayout"}),(0,o.kt)("sub",null,(0,o.kt)("sup",null," NOTE: These docs are under active development \ud83d\udc77\u200d\u2640\ufe0f\ud83d\udc77 ")),(0,o.kt)("hr",null),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},"Subgraph Uncrashable by Float")," is a code generation tool that generates a set of helper functions from the graphql scheme of the project. "),(0,o.kt)("p",null,"This completely abstracts the need for subgraph developers to call ",(0,o.kt)("inlineCode",{parentName:"p"},"new Entity"),", ",(0,o.kt)("inlineCode",{parentName:"p"},"Entity.load")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"Entity.save()")," functions which are all inherently error prone, and in turn ensures that all interactions with entities in the subgraph are completely safe. "),(0,o.kt)("p",null,"Please note, this doesn\u2019t mean that the subgraph code won\u2019t have logic errors. Sometimes it is useful for a subgraph to crash when things appear to go wrong (e.g. while it is syncing historic data), other times you want it to keep going but alert the development team that there is an issue so they can rectify things as soon as possible. We have gone with the approach of allowing the subgraph developer to specify a timestamp after which the subgraph should no-longer crash on error but rather keep going using our default entity approach."),(0,o.kt)("p",null,"The code generation tool accommodates all subgraph types and is configurable for users to set  sane defaults on values. The code generation will use this config to generate helper functions that are to the users specification."),(0,o.kt)("p",null,"The framework also includes a way (via the config file) to create custom but safe setter functions for groups of entity variables. This way it is impossible for the user to load/use a stale graph entity and it is also impossible to forget to save or set a variable that is required by the function."),(0,o.kt)("p",null,"Warning logs are recorded as warning logs indicating where there is a breach of subgraph logic to help patch the issue to ensure data accuracy. These logs can be viewed in the The Graph's hosted service under the 'Logs' section."))}u.isMDXComponent=!0}}]);